{
    "docs": [
        {
            "location": "/", 
            "text": "Home \u00b7 Coluna\ndocumenterBaseURL=\".\"\nColuna\nHome\nManual Outline\nInstallation\nIntroduction\nBasic Example\nHome\n\uf09b\n Edit on GitHub\nHome\nHome\nColuna.jl package provides a branch-and-price-and-cut framework that can decompose (with user hints) and solve models formulated with JuMP (or MOI). It relies on MOI optimizers in order to solve the decomposed blocks (master, pricing, separation...).\nThe user must be familiar with the syntax of JuMP, which is described in its \ndocumentation\n.\nManual Outline\nHome\nInstallation Guide\nIntroduction\nBasic example\nNext\nInstallation", 
            "title": "Home"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation \u00b7 Coluna\ndocumenterBaseURL=\".\"\nColuna\nHome\nInstallation\nGetting Coluna.jl\nIntroduction\nBasic Example\nInstallation\n\uf09b\n Edit on GitHub\nInstallation\nInstallation Guide\nColuna requires Julia, MOI and GLPK as the default underlying MOI Optimizer for the master and the subproblems.\nGetting Coluna.jl\nColuna.jl can be installed using the package manager of Julia. To install it:\nGo the Pkg-REPL-mode. The Pkg REPL-mode is entered from the Julia REPL using the key ].\nThen run the following command\n(1.0) pkg\n add Coluna\nThis command will, recursively, install Coluna.jl and its dependencies.\nTo start using Coluna.jl, it should be imported into the local scope.\nusing Coluna\nPrevious\nHome\nNext\nIntroduction", 
            "title": "Installation"
        }, 
        {
            "location": "/introduction/", 
            "text": "Introduction \u00b7 Coluna\ndocumenterBaseURL=\".\"\nColuna\nHome\nInstallation\nIntroduction\nDantzig-Wolfe decomposition\nBasic Example\nIntroduction\n\uf09b\n Edit on GitHub\nIntroduction\nIntroduction\nColuna.jl solves Mixed Integer Programs (MIP) by applying reformulation techniques such as Dantzig-Wolfe or Benders decomposition. The reformulated problem is solved using a branch-and-price-and-cut (column and row generation) algorithm. The specificity of Coluna.jl is to offer a \u201cblack-box\u201d implementation of the method:\nthe input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI);\nthe user specifies which of these constraints and variables define the subsystems on which the decomposition is based (it is handy to test different decompositions);\nthe reformulation is automatically generated by Coluna, without any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound;\na default column generation procedure is implemented. It relies on underlying MOI optimizers to handle master and subproblem but the user can define its own optimizer;\na branching scheme that preserves the pricing problem structure is offered by default; it runs based on priorities and directives specified by the user on the original variables; default primal heuristics and preprocessing features are under developments.\nNote\nBenders decomposition is not yet implemented but will be in the future.\nDantzig-Wolfe decomposition\nConsider the following problem :\n\\[\\begin{array}{c c c c c c c}\n\\text{minimize}  \n \\sum_{\\alpha=1}^i f_\\alpha x_\\alpha     \n + \n \\sum_{\\alpha=1}^j f_{i+\\alpha} x_{i+\\alpha}     \n + \n \\sum_{\\alpha=1}^k f_{i+j+\\alpha} x_{i+j+\\alpha}   \n      \n             \\\\\n\\text{mc}_{1}:   \n \\sum_{\\alpha=1}^i a_{1,\\alpha} x_\\alpha \n + \n \\sum_{\\alpha=1}^j a^{1}_{i+\\alpha} x_{i+\\alpha} \n + \n \\sum_{\\alpha=1}^k a_{1,i+j+\\alpha} x_{i+j+\\alpha} \n \\geq \n \\beta_{0,1} \\\\\n\\vdots           \n \\vdots                                  \n   \n \\vdots                                          \n   \n \\vdots                                            \n      \n             \\\\\n\\text{mc}_{m}:   \n \\sum_{\\alpha=1}^i a_{m,\\alpha} x_\\alpha \n + \n \\sum_{\\alpha=1}^j a^{m}_{i+\\alpha} x_{i+\\alpha} \n + \n \\sum_{\\alpha=1}^k a_{m,i+j+\\alpha} x_{i+j+\\alpha} \n \\geq \n \\beta_{0,m} \\\\\n\\text{sc}_{1,1}: \n \\sum_{\\alpha=1}^i b_{1,\\alpha} x_\\alpha \n   \n                                                 \n   \n                                                   \n \\geq \n \\beta_{1,1} \\\\\n\\vdots           \n \\vdots                                  \n   \n                                                 \n   \n                                                   \n      \n             \\\\\n\\text{sc}_{1,n}: \n \\sum_{\\alpha=1}^i b_{n,\\alpha} x_\\alpha \n   \n                                                 \n   \n                                                   \n \\geq \n \\beta_{1,n} \\\\\n\\text{sc}_{2,1}: \n                                         \n   \n \\sum_{\\alpha=1}^j c_{1,i+\\alpha} x_{i+\\alpha}   \n   \n                                                   \n \\geq \n \\beta_{2,1} \\\\\n\\vdots           \n                                         \n   \n \\vdots                                          \n   \n                                                   \n      \n             \\\\\n\\text{sc}_{2,p}: \n                                         \n   \n \\sum_{\\alpha=1}^j c_{p,i+\\alpha} x_{i+\\alpha}   \n   \n                                                   \n \\geq \n \\beta_{2,p} \\\\\n\\text{sc}_{3,1}: \n                                         \n   \n                                                 \n   \n \\sum_{\\alpha=1}^k d_{1,i+j+\\alpha} x_{i+j+\\alpha} \n \\geq \n \\beta_{3,1} \\\\\n\\vdots           \n                                         \n   \n                                                 \n   \n \\vdots                                            \n      \n             \\\\\n\\text{sc}_{3,q}: \n                                         \n   \n                                                 \n   \n \\sum_{\\alpha=1}^k d_{q,i+j+\\alpha} x_{i+j+\\alpha} \n \\geq \n \\beta_{3,q} \\\\\n\\end{array}\\]\nThe coefficients matrix has the following block structure :\nHence, we can apply \nDantzig-Wolfe decomposition\n on this problem.\nWe partition the constraints.\nConstraints \n$\\text{mc}_1$\n to \n$\\text{mc}_m$\n are in the master.\nConstraints \n$\\text{sc}_{1,1}$\n to \n$\\text{sc}_{1,q}$\n are in the first subproblem.\nConstraints \n$\\text{sc}_{2,1}$\n to \n$\\text{sc}_{2,q}$\n are in the second subproblem.\nConstraints \n$\\text{sc}_{3,1}$\n to \n$\\text{sc}_{3,q}$\n are in the third subproblem.\nThis decomposition is described through the following annotations:\n# setting constraint annotations for the decomposition\nfor o in 1:3, p in 1:q\n    # constraint in subproblem i\n    # (subproblem annotations need to be contiguous starting at 1)\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), sc[o, p], i)\nend\nfor o in 1:m\n    # constraint in master (annotated with 0)\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), mc[o], 0)\nend\n# setting variable annotations for the decomposition in the same way\nfor o in 1:i\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 1)\nend\nfor o in (i+1):j\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 2)\nend\nfor o in (i+j+1):k\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 2)\nend\nPrevious\nInstallation\nNext\nBasic Example", 
            "title": "Introduction"
        }, 
        {
            "location": "/basic/", 
            "text": "Basic Example \u00b7 Coluna\ndocumenterBaseURL=\".\"\nColuna\nHome\nInstallation\nIntroduction\nBasic Example\nBlockModel instantiation\nWrite the model\nDecomposition\nBasic Example\n\uf09b\n Edit on GitHub\nBasic Example\nBasic example\nThis quick start guide introduces features of Coluna.jl package.\nBlockModel instantiation\nA JuMP model using Coluna model can be instantiated as\n  using JuMP\n  import Coluna\n  gap = Model(with_optimizer(Coluna.Optimizer))\nWrite the model\nThe model is written as a JuMP model. If you are not familiar with JuMP syntax, you may want to check its \ndocumentation\n.\nConsider a set of machines \nMachines = 1:M\n and a set of jobs \nJobs = 1:J\n. A machine \nm\n has a resource capacity \nCapacity[m]\n. When we assign a job \nj\n to a machine \nm\n, the job has a cost \nCost[m,j]\n and consumes \nWeight[m,j]\n resources of the machine \nm\n. The goal is to minimize the jobs cost sum by assigning each job to a machine while not exceeding the capacity of each machine. The model is:\n@variable(gap, x[m in data.machines, j in data.jobs], Bin)\n\n\n@constraint(gap, cov[j in data.jobs],\n        sum(x[m,j] for m in data.machines) \n= 1)\n\n\n@constraint(gap, knp[m in data.machines],\n        sum(data.weight[j, m] * x[m, j] for j in data.jobs) \n= data.capacity[m])\n\n\n@objective(gap, Min,\n        sum(data.cost[j, m] * x[m, j] for m in data.machines, j in data.jobs))\nDecomposition\nThe decomposition is described through the following annotations:\n# setting constraint annotations for the decomposition\nfor j in data.jobs\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), cov[j], 0)\nend\nfor m in data.machines\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), knp[m], m)\nend\n\n\nsetting variable annotations for the decomposition\n\n\nfor m in data.machines, j in data.jobs\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[m, j], m)\nend\nNow you can solve the problem and get the solution values as you do with JuMP when using any other Optimizer.\nOther examples are available \nhere\nPrevious\nIntroduction", 
            "title": "Basic Example"
        }, 
        {
            "location": "/basic/#setting-variable-annotations-for-the-decomposition", 
            "text": "for m in data.machines, j in data.jobs\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[m, j], m)\nend Now you can solve the problem and get the solution values as you do with JuMP when using any other Optimizer. Other examples are available  here Previous Introduction", 
            "title": "setting variable annotations for the decomposition"
        }
    ]
}
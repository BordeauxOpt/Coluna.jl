var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#Home-1",
    "page": "Home",
    "title": "Home",
    "category": "section",
    "text": "Coluna.jl package provides a branch-and-price-and-cut framework that can decompose (with user hints) and solve models formulated with JuMP (or MOI). It relies on MOI optimizers in order to solve the decomposed blocks (master, pricing, separation...).The user must be familiar with the syntax of JuMP, which is described in its documentation."
},

{
    "location": "index.html#Manual-Outline-1",
    "page": "Home",
    "title": "Manual Outline",
    "category": "section",
    "text": "Pages = [\n    \"index.md\",\n    \"installation.md\",\n    \"introduction.md\",\n    \"basic.md\",\n]\nDepth = 1"
},

{
    "location": "installation.html#",
    "page": "Installation",
    "title": "Installation",
    "category": "page",
    "text": ""
},

{
    "location": "installation.html#Installation-Guide-1",
    "page": "Installation",
    "title": "Installation Guide",
    "category": "section",
    "text": "Coluna requires Julia, MOI and GLPK as the default underlying MOI Optimizer for the master and the subproblems."
},

{
    "location": "installation.html#Getting-Coluna.jl-1",
    "page": "Installation",
    "title": "Getting Coluna.jl",
    "category": "section",
    "text": "Coluna.jl can be installed using the package manager of Julia. To install it:Go the Pkg-REPL-mode. The Pkg REPL-mode is entered from the Julia REPL using the key ].\nThen run the following command\n(1.0) pkg> add ColunaThis command will, recursively, install Coluna.jl and its dependencies.To start using Coluna.jl, it should be imported into the local scope.using Coluna"
},

{
    "location": "introduction.html#",
    "page": "Introduction",
    "title": "Introduction",
    "category": "page",
    "text": ""
},

{
    "location": "introduction.html#Introduction-1",
    "page": "Introduction",
    "title": "Introduction",
    "category": "section",
    "text": "Coluna.jl solves Mixed Integer Programs (MIP) by applying reformulation techniques such as Dantzig-Wolfe or Benders decomposition. The reformulated problem is solved using a branch-and-price-and-cut (column and row generation) algorithm. The specificity of Coluna.jl is to offer a “black-box” implementation of the method:the input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI);\nthe user specifies which of these constraints and variables define the subsystems on which the decomposition is based (it is handy to test different decompositions);\nthe reformulation is automatically generated by Coluna, without any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound;\na default column generation procedure is implemented. It relies on underlying MOI optimizers to handle master and subproblem but the user can define its own optimizer;\na branching scheme that preserves the pricing problem structure is offered by default; it runs based on priorities and directives specified by the user on the original variables; default primal heuristics and preprocessing features are under developments.note: Note\nBenders decomposition is not yet implemented but will be in the future."
},

{
    "location": "introduction.html#Dantzig-Wolfe-decomposition-1",
    "page": "Introduction",
    "title": "Dantzig-Wolfe decomposition",
    "category": "section",
    "text": "Consider the following problem :beginarrayc c c c c c c\ntextminimize   sum_alpha=1^i f_alpha x_alpha      +  sum_alpha=1^j f_i+alpha x_i+alpha      +  sum_alpha=1^k f_i+j+alpha x_i+j+alpha                      \ntextmc_1    sum_alpha=1^i a_1alpha x_alpha  +  sum_alpha=1^j a^1_i+alpha x_i+alpha  +  sum_alpha=1^k a_1i+j+alpha x_i+j+alpha  geq  beta_01 \nvdots            vdots                                      vdots                                              vdots                                                               \ntextmc_m    sum_alpha=1^i a_malpha x_alpha  +  sum_alpha=1^j a^m_i+alpha x_i+alpha  +  sum_alpha=1^k a_mi+j+alpha x_i+j+alpha  geq  beta_0m \ntextsc_11  sum_alpha=1^i b_1alpha x_alpha                                                                                                            geq  beta_11 \nvdots            vdots                                                                                                                                                               \ntextsc_1n  sum_alpha=1^i b_nalpha x_alpha                                                                                                            geq  beta_1n \ntextsc_21                                              sum_alpha=1^j c_1i+alpha x_i+alpha                                                          geq  beta_21 \nvdots                                                        vdots                                                                                                                   \ntextsc_2p                                              sum_alpha=1^j c_pi+alpha x_i+alpha                                                          geq  beta_2p \ntextsc_31                                                                                                  sum_alpha=1^k d_1i+j+alpha x_i+j+alpha  geq  beta_31 \nvdots                                                                                                            vdots                                                               \ntextsc_3q                                                                                                  sum_alpha=1^k d_qi+j+alpha x_i+j+alpha  geq  beta_3q \nendarrayThe coefficients matrix has the following block structure :(Image: DWImg)Hence, we can apply Dantzig-Wolfe decomposition on this problem.We partition the constraints.Constraints textmc_1 to textmc_m are in the master.\nConstraints textsc_11 to textsc_1q are in the first subproblem.\nConstraints textsc_21 to textsc_2q are in the second subproblem.\nConstraints textsc_31 to textsc_3q are in the third subproblem.This decomposition is described through the following annotations:# setting constraint annotations for the decomposition\nfor o in 1:3, p in 1:q\n    # constraint in subproblem i\n    # (subproblem annotations need to be contiguous starting at 1)\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), sc[o, p], i)\nend\nfor o in 1:m\n    # constraint in master (annotated with 0)\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), mc[o], 0)\nend\n# setting variable annotations for the decomposition in the same way\nfor o in 1:i\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 1)\nend\nfor o in (i+1):j\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 2)\nend\nfor o in (i+j+1):k\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[o, p], 2)\nend"
},

{
    "location": "basic.html#",
    "page": "Basic Example",
    "title": "Basic Example",
    "category": "page",
    "text": ""
},

{
    "location": "basic.html#Basic-example-1",
    "page": "Basic Example",
    "title": "Basic example",
    "category": "section",
    "text": "This quick start guide introduces features of Coluna.jl package."
},

{
    "location": "basic.html#Model-instantiation-1",
    "page": "Basic Example",
    "title": "Model instantiation",
    "category": "section",
    "text": "A JuMP model using Coluna model can be instantiated as  using JuMP\n  import Coluna\n  gap = Model(with_optimizer(Coluna.Optimizer))"
},

{
    "location": "basic.html#Write-the-model-1",
    "page": "Basic Example",
    "title": "Write the model",
    "category": "section",
    "text": "The model is written as a JuMP model. If you are not familiar with JuMP syntax, you may want to check its documentation.Consider a set of machines Machines = 1:M and a set of jobs Jobs = 1:J. A machine m has a resource capacity Capacity[m]. When we assign a job j to a machine m, the job has a cost Cost[m,j] and consumes Weight[m,j] resources of the machine m. The goal is to minimize the jobs cost sum by assigning each job to a machine while not exceeding the capacity of each machine. The model is:@variable(gap, x[m in data.machines, j in data.jobs], Bin)\n\n@constraint(gap, cov[j in data.jobs],\n        sum(x[m,j] for m in data.machines) >= 1)\n\n@constraint(gap, knp[m in data.machines],\n        sum(data.weight[j, m] * x[m, j] for j in data.jobs) <= data.capacity[m])\n\n@objective(gap, Min,\n        sum(data.cost[j, m] * x[m, j] for m in data.machines, j in data.jobs))"
},

{
    "location": "basic.html#Decomposition-1",
    "page": "Basic Example",
    "title": "Decomposition",
    "category": "section",
    "text": "The decomposition is described through the following annotations:# setting constraint annotations for the decomposition\nfor j in data.jobs\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), cov[j], 0)\nend\nfor m in data.machines\n    set(gap, Coluna.ConstraintDantzigWolfeAnnotation(), knp[m], m)\nend\n\n# setting variable annotations for the decomposition\nfor m in data.machines, j in data.jobs\n    set(gap, Coluna.VariableDantzigWolfeAnnotation(), x[m, j], m)\nendNow you can solve the problem and get the solution values as you do with JuMP when using any other Optimizer.Other examples are available here"
},

]}

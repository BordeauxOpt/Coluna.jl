var documenterSearchIndex = {"docs":
[{"location":"user/callbacks/#Callbacks-1","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Callbacks are functions defined by the user that allow him to take over part of the default  algorithm.  The more classical callbacks in a branch-and-price solver are:","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Pricing callback that takes over the procedure to determine whether the current master LP    solution is optimum or produce an entering variable with negative reduced cost\nSeparation callback that takes over the procedure to determine whether the current master   LP solution is feasible or produce a valid problem constraint that is violated\nBranching callback that take over the procedure to determine whether the current master    LP solution is integer or produce a valid branching disjunctive constraint that rules out    the current fractional solution.","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"In this page, we use following aliases : ","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"const BD = BlockDecomposition\nconst MOI = MathOptInterface","category":"page"},{"location":"user/callbacks/#Pricing-callback-1","page":"Callbacks","title":"Pricing callback","text":"","category":"section"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"The pricing callback let you define how to solve the subproblems of a Dantzig-Wolfe  decomposition to generate a new entering column in the master program.  This callback is usefull when you know an efficient algorithm to solve the subproblems,  i.e. an algorithm better than solving the subproblem with a MIP solver.","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Let us see an example with the generalized assignment problem for which the JuMP model takes the form:","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"model = BlockModel(optimizer, bridge_constraints = false)\n\n@axis(M, 1:nb_machines)\nJ = 1:nb_jobs\n\n# JuMP model\n@variable(model, x[m in M, j in J], Bin)\n@constraint(model, cov[j in J], sum(x[m,j] for m in M) == 1)\n@objective(model, Min, sum(c[j,m]*x[m,j] for m in M, j in J))\n@dantzig_wolfe_decomposition(model, dwdec, M)","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"where as you can see, we omitted the knapsack constraints.  These constraints are implicitly defined by the algorithm called in the pricing callback.","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Assume we have the following method that solves efficienlty a knapsack problem:","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"solve_knp(job_costs, lb_jobs, ub_jobs, capacity)","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"where ","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"job_costs is an array that contains the cost of each job\nlb_jobs is an array where the j-th entry equals 1 if it is mandatory to put job j in the knapsack\nub_jobs is an array where the j-th entry equals 0 if job j cannot be put in the knapsack\ncapacity is a real that is equal to the capacity of the knapsack","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"The pricing callback is a function. It takes as argument cbdata which is a data structure that allows the user to interact with the solver within the pricing callback.","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"function my_pricing_callback(cbdata)\n    # Retrieve the index of the subproblem (it will be one of the values in M)\n    cur_machine = BD.callback_spid(cbdata, model)\n\n    # Retrieve reduced costs of subproblem variables\n    red_costs = [BD.callback_reduced_cost(cbdata, x[cur_machine, j]) for j in J]\n\n    # Retrieve current bounds of subproblem variables\n    lb_x = [BD.callback_lb(cbdata, x[cur_machine, j]) for j in J]\n    ub_x = [BD.callback_ub(cbdata, x[cur_machine, j]) for j in J]\n\n    # Solve the knapsack with a custom algorithm\n    jobs_assigned_to_cur_machine = solve_knp(red_costs, lb_x, ub_x, Q[cur_machine])\n\n    # Create the solution (send only variables with non-zero values)\n    sol_vars = [x[cur_machine, j] for j in jobs_assigned_to_cur_machine]\n    sol_vals = [1 for j in jobs_assigned_to_cur_machine]\n    sol_cost = sum(redcosts[j] for j in jobs_assigned_to_cur_machine)\n\n    # Submit the solution to the subproblem to Coluna\n    MOI.submit!(model, BD.PricingSolution(cbdata), sol_cost, sol_vars, sol_vals)\n    return\nend","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"The pricing callback is provided to Coluna using the keyword solver in the method  specify!.","category":"page"},{"location":"user/callbacks/#","page":"Callbacks","title":"Callbacks","text":"master = BD.getmaster(dwdec)\nsubproblems = BD.getsubproblems(dwdec)\nBD.specify!.(subproblems, lower_multiplicity = 0, solver = my_pricing_callback)","category":"page"},{"location":"user/start/#Quick-start-1","page":"Getting started","title":"Quick start","text":"","category":"section"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"This quick start guide introduces the main features of Coluna through the example of the Generalized Assignement Problem.","category":"page"},{"location":"user/start/#Problem-1","page":"Getting started","title":"Problem","text":"","category":"section"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Consider a set of machines M = 1:nb_machines and a set of jobs J = 1:nb_jobs. A machine m has a resource capacity Q_m .  A job j assigned to a machine m has a cost c_mj and consumes w_mj resource units of the machine m.  The goal is to minimize the sum of job costs while assigning each job to a machine and not  exceeding the capacity of each machine.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Let x_mj equal to one if job j is assigned to machine m; 0 otherwise. The problem has the original formulation:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"beginalignedat4 \ntextGAP equiv min mathrlapsum_m in M c_mj x_mj  \ntextst  sum_m in M x_mj = 1  quad j in J \n sum_j in J w_mj x_mj leq Q_m Â quad  quad m in M  \n x_mj  in 01  m in M j in J\nendalignedat","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"In this tutorial, you will solve the instance below using a \"simple\" branch-and-cut-and-price algorithm:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"nb_machines = 4\nnb_jobs = 30\nc = [12.7 22.5 8.9 20.8 13.6 12.4 24.8 19.1 11.5 17.4 24.7 6.8 21.7 14.3 10.5 15.2 14.3 12.6 9.2 20.8 11.7 17.3 9.2 20.3 11.4 6.2 13.8 10.0 20.9 20.6;  19.1 24.8 24.4 23.6 16.1 20.6 15.0 9.5 7.9 11.3 22.6 8.0 21.5 14.7 23.2 19.7 19.5 7.2 6.4 23.2 8.1 13.6 24.6 15.6 22.3 8.8 19.1 18.4 22.9 8.0;  18.6 14.1 22.7 9.9 24.2 24.5 20.8 12.9 17.7 11.9 18.7 10.1 9.1 8.9 7.7 16.6 8.3 15.9 24.3 18.6 21.1 7.5 16.8 20.9 8.9 15.2 15.7 12.7 20.8 10.4;  13.1 16.2 16.8 16.7 9.0 16.9 17.9 12.1 17.5 22.0 19.9 14.6 18.2 19.6 24.2 12.9 11.3 7.5 6.5 11.3 7.8 13.8 20.7 16.8 23.6 19.1 16.8 19.3 12.5 11.0]\nw = [61 70 57 82 51 74 98 64 86 80 69 79 60 76 78 71 50 99 92 83 53 91 68 61 63 97 91 77 68 80; 50 57 61 83 81 79 63 99 82 59 83 91 59 99 91 75 66 100 69 60 87 98 78 62 90 89 67 87 65 100; 91 81 66 63 59 81 87 90 65 55 57 68 92 91 86 74 80 89 95 57 55 96 77 60 55 57 56 67 81 52;  62 79 73 60 75 66 68 99 69 60 56 100 67 68 54 66 50 56 70 56 72 62 85 70 100 57 96 69 65 50]\nQ = [1020 1460 1530 1190]","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"This model has a block structure : each knapsack constraint defines an independent block and the set-partitionning constraints couple these independent  blocks. By applying the Dantzig-Wolfe reformulation, each knapsack constraint forms a tractable subproblem and the set-partitionning constraints are handled in a master problem.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"To introduce the model, you need to load packages JuMP and BlockDecomposition. To optimize the problem, you need Coluna and a Julia package that provides a MIP solver such as GLPK.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"using JuMP, BlockDecomposition, Coluna, GLPK ","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Next you instantiate the solver and define the algorithm that you use to optimize the problem. In this case, the algorithm is a \"simple\" branch-and-cut-and-price provided by Coluna.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"coluna = optimizer_with_attributes(\n    Coluna.Optimizer,\n    \"params\" => Coluna.Params(\n        solver = Coluna.Algorithm.TreeSearchAlgorithm() # default BCP\n    ),\n    \"default_optimizer\" => GLPK.Optimizer # GLPK for the master & the subproblems\n)","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"In BlockDecomposition, an axis is the index set of subproblems.  Let M be the index set of machines; it defines an axis along which we can implement the desired decomposition. In this example, the axis M defines one knapsack subproblem for  each machine.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Jobs are not involved in the decomposition, you thus define the set J of jobs as a classic range.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"@axis(M, 1:nb_machines)\nJ = 1:nb_jobs","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"The model takes the form (argument bridge_constraints = false is mandatory because of a  bug in our interface):","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"model = BlockModel(coluna, bridge_constraints = false)\n@variable(model, x[m in M, j in J], Bin)\n@constraint(model, cov[j in J], sum(x[m, j] for m in M) >= 1)\n@constraint(model, knp[m in M], sum(w[m, j] * x[m, j] for j in J) <= Q[m])\n@objective(model, Min, sum(c[m, j] * x[m, j] for m in M, j in J))","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"You then apply a Dantzig-Wolfe decomposition along the M axis:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"@dantzig_wolfe_decomposition(model, decomposition, M)","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"where decomposition is a variable that contains information about the decomposition.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Once the decomposition is defined, you can retrieve the master and the subproblems to give additional information to the solver.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"master = getmaster(decomposition)\nsubproblems = getsubproblems(decomposition)","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"The multiplicity of a subproblem is the number of times that the same independent block  shaped by the subproblem appears in the model. This multiplicy also specifies the number of  solutions to the subproblem that can appear in the solution to the original problem. ","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"In this GAP instance, the upper multiplicity is 1 because every subproblem is different,  i.e., every machine is different and used at most once.","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"The lower multiplicity is 0 because a machine may stay unused.  The multiplicity specifications take the form:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"specify!.(subproblems, lower_multiplicity = 0, upper_multiplicity = 1)","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"The model is now fully defined. To solve it, you need to call:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"optimize!(model)","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"Finally, you can retrieve the solution to the original formulation with JuMP methods. For example:","category":"page"},{"location":"user/start/#","page":"Getting started","title":"Getting started","text":"value.(x[1,:])  # j-th position is equal to 1 if job j assigned to machine 1","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coluna is a framework written in Julia to implement a decomposition approach to optimize  block structured mixed-integer programs (MIP). ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coluna relies on the tools of the JuliaOpt community at both ends of the problem treatment.  It uses the JuMP modeling language up front and MathOptInterface (MOI) to delegate master  and subproblems to MIP solvers. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The user introduces an original MIP that model his problem using the JuMP along our specific  extension BlockDecomposition that offers a syntax to specify the problem decomposition.  Coluna reformulates the original MIP using Dantzig-Wolfe and Benders decomposition  techniques.  Then, Coluna optimizes the reformulation using the algorithm chosen by the user.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coluna offers a \"black-box\" implementation of the branch-and-cut-and-price algorithm:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI). \nBlockDecomposition allows the user to provide to Coluna his instructions on the desired decomposition of the model.   The BlockDecomposition syntax allows the user to implicilty define subsystems in the MIP on which the decomposition is based.   These subsystems are described by rows and/or columns indices. This syntax is handy to test different decompositions.\nThe reformulation associated to a so-defined decomposition is automatically generated by Coluna,  without requiring any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound.\nA default column (and cut) generation procedure is implemented.  It relies on underlying MOI optimizers to handle master and subproblems.   However, the user can define its own optimizer using pricing callbacks.\nA branching scheme that preserves the pricing problem structure is offered by default;   it runs based on priorities and directives specified by the user on the original variables;   default primal heuristics and preprocessing features are under developments.","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coluna is a package for Julia 1.0+","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"It requires JuMP to model the problem, BlockDecomposition to define the decomposition, and a MIP solver supported by MathOptInterface to optimize the master and the subproblems. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can install Coluna and its dependencies through the package manager of Julia by entering :","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"] add Coluna","category":"page"},{"location":"#Contributions-1","page":"Introduction","title":"Contributions","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"We welcome all contributions that help us to improve Coluna. You can suggest ways to enhance the package by talking with developers on the discord chat dedicated to Coluna, or opening an issue via the GitHub issues tracker","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Once the suggestion approved, you can open a Pull Request (PR) with the implementation of your suggestion. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Before requesting the review, make sure that your code follows the style guide and passes tests.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Do no forget to update docstrings and the tests when necessary. It is very important to keep clear the goal of the PR to make the review fast. So we might close a PR that fixes two unrelated issues or more. ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coluna style follows the blue style guide for Julia amended by the following instruction on naming :","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Names of variables and functions are treated equally. Use names that express what the variable/function do. > Either use : lowercasenospace when the nam``is composed of three words or less with no ambiguity on words separation.\nsnake_case otherwise","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Note that the application of the style guide is a work in progress.","category":"page"},{"location":"#Acknowledgements-1","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Atoptima, Mathematical Optimization Society (MOS), University of Bordeaux, and Inria","category":"page"}]
}

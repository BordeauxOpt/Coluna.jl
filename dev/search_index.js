var documenterSearchIndex = {"docs":
[{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Coluna.jl package provides a branch-and-price-and-cut framework that can decompose (with user hints) and solve models formulated with JuMP (or MOI). It relies on MOI optimizers in order to solve the decomposed blocks (master, pricing, separation...).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The user must be familiar with the syntax of JuMP, which is described in its documentation.","category":"page"},{"location":"#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"installation.md\",\n    \"introduction.md\",\n    \"basic.md\",\n]\nDepth = 1","category":"page"},{"location":"installation/#Installation-Guide-1","page":"Installation","title":"Installation Guide","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Coluna is a package for Julia. ","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"It requires JuMP and GLPK as the default underlying MOI Optimizer for the master and the subproblems.","category":"page"},{"location":"installation/#Getting-Coluna.jl-1","page":"Installation","title":"Getting Coluna.jl","text":"","category":"section"},{"location":"installation/#","page":"Installation","title":"Installation","text":"Coluna.jl can be installed using the package manager of Julia.  Go to the Pkg-REPL-mode.  The Pkg REPL-mode is entered from the Julia REPL using the key ].  Then, run the following command :","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"   pkg> add https://github.com/atoptima/Coluna.jl.git\n   ```\nThis command will install Coluna.jl and its dependencies.\n\nYou can start using Coluna by doing :","category":"page"},{"location":"installation/#","page":"Installation","title":"Installation","text":"julia using Coluna ```","category":"page"},{"location":"introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Coluna.jl solves Mixed Integer Programs (MIP) by applying reformulation techniques such as Dantzig-Wolfe decomposition. The reformulated problem is solved using a branch-and-price-and-cut (column and row generation) algorithm. The specificity of Coluna.jl is to offer a “black-box” implementation of the method:","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"the input is the set of constraints and variables of the MIP in its natural/compact formulation (formulated with JuMP or MOI); the Block-Decompostion.jl package offers extensions to the modeling language JuMP to allow the user to provide instructions on decomposition to Coluna;\nthe user defines subsystems in the MIP on which the decomposition is based; subsystems are described by rows and/or columns indices; this is handy to test different decompositions;\nthe reformulation is automatically generated by Coluna, without any input from the user to define master columns, their reduced cost, pricing/separation problem, or Lagrangian bound;\na default column and cut generation procedure is implemented. It relies on underlying MOI optimizers to handle master and subproblem but the user can define its own optimizer;\na branching scheme that preserves the pricing problem structure is offered by default; it runs based on priorities and directives specified by the user on the original variables; default primal heuristics and preprocessing features are under developments.","category":"page"},{"location":"introduction/#Future-Developments-1","page":"Introduction","title":"Future Developments","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"​    Benders decomposition is not yet implemented but will be in the near future, along side the option of using a combined Dantzig-Wolfe and Benders decomposition ","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Further devlopments include recurcive Dantzig-Wolfe or Benders decomposition, i.e., the subproblem is itself solved using a decomposition approach.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Last but not leased, many process of the global approach will be running on parallel machines: some using muti-coore; orther using distributed computing.","category":"page"},{"location":"introduction/#Dantzig-Wolfe-decomposition-1","page":"Introduction","title":"Dantzig-Wolfe decomposition","text":"","category":"section"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nThis example is outdated.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Consider the following problem :","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"beginarrayc c c c c c c\ntextminimize   sum_alpha=1^i f_alpha x_alpha      +  sum_alpha=1^j f_i+alpha x_i+alpha      +  sum_alpha=1^k f_i+j+alpha x_i+j+alpha                      \ntextmc_1    sum_alpha=1^i a_1alpha x_alpha  +  sum_alpha=1^j a^1_i+alpha x_i+alpha  +  sum_alpha=1^k a_1i+j+alpha x_i+j+alpha  geq  beta_01 \nvdots            vdots                                      vdots                                              vdots                                                               \ntextmc_m    sum_alpha=1^i a_malpha x_alpha  +  sum_alpha=1^j a^m_i+alpha x_i+alpha  +  sum_alpha=1^k a_mi+j+alpha x_i+j+alpha  geq  beta_0m \ntextsc_11  sum_alpha=1^i b_1alpha x_alpha                                                                                                            geq  beta_11 \nvdots            vdots                                                                                                                                                               \ntextsc_1n  sum_alpha=1^i b_nalpha x_alpha                                                                                                            geq  beta_1n \ntextsc_21                                              sum_alpha=1^j c_1i+alpha x_i+alpha                                                          geq  beta_21 \nvdots                                                        vdots                                                                                                                   \ntextsc_2p                                              sum_alpha=1^j c_pi+alpha x_i+alpha                                                          geq  beta_2p \ntextsc_31                                                                                                  sum_alpha=1^k d_1i+j+alpha x_i+j+alpha  geq  beta_31 \nvdots                                                                                                            vdots                                                               \ntextsc_3q                                                                                                  sum_alpha=1^k d_qi+j+alpha x_i+j+alpha  geq  beta_3q \nendarray","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"The coefficients matrix has the following block structure :","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"(Image: DWImg)","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Hence, we can apply Dantzig-Wolfe decomposition on this problem.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"We partition the constraints.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"Constraints textmc_1 to textmc_m are in the master.\nConstraints textsc_11 to textsc_1q are in the first subproblem.\nConstraints textsc_21 to textsc_2q are in the second subproblem.\nConstraints textsc_31 to textsc_3q are in the third subproblem.","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"This decomposition is described through the following annotations:","category":"page"},{"location":"introduction/#","page":"Introduction","title":"Introduction","text":"warning: Warning\nTo do.","category":"page"},{"location":"basic/#Basic-example-(Generalized-Assignment-Problem)-1","page":"Basic Example","title":"Basic example (Generalized Assignment Problem)","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"This quick start guide introduces features of Coluna.jl package.","category":"page"},{"location":"basic/#Model-instantiation-1","page":"Basic Example","title":"Model instantiation","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"A JuMP model using Coluna model can be instantiated as","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"  using JuMP\n  import Coluna\n  gap = Model(with_optimizer(Coluna.Optimizer))","category":"page"},{"location":"basic/#Write-the-model-1","page":"Basic Example","title":"Write the model","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"The model is written as a JuMP model. If you are not familiar with JuMP syntax, you may want to check its documentation.","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Consider a set of machines Machines = 1:M and a set of jobs Jobs = 1:J. A machine m has a resource capacity Capacity[m]. When we assign a job j to a machine m, the job has a cost Cost[m,j] and consumes Weight[m,j] resources of the machine m. The goal is to minimize the jobs cost sum by assigning each job to a machine while not exceeding the capacity of each machine. The model is:","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"gap = Model(with_optimizer(AnySolver.Optimizer))\n\n@variable(gap, x[m in data.machines, j in data.jobs], Bin)\n\n@constraint(gap, cov[j in data.jobs],\n        sum(x[m,j] for m in data.machines) >= 1)\n\n@constraint(gap, knp[m in data.machines],\n        sum(data.weight[j, m] * x[m, j] for j in data.jobs) <= data.capacity[m])\n\n@objective(gap, Min,\n        sum(data.cost[j, m] * x[m, j] for m in data.machines, j in data.jobs))","category":"page"},{"location":"basic/#Decomposition-1","page":"Basic Example","title":"Decomposition","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Since the knapsack problem is tractable, we decompose the problem  over machines to obtain one knapsack subproblem per machine. ","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"The decomposition is described through an axis.  Each index of the axis represents a subproblem.","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"@axis(M, data.machine)","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"We define the indices of variables and constraints using this axis.","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"gap = BlockModel(with_optimizer(Coluna.Optimizer))\n\n@variable(gap, x[m in M, j in data.jobs], Bin)\n\n@constraint(gap, cov[j in data.jobs],\n        sum(x[m,j] for m in M) >= 1)\n\n@constraint(gap, knp[m in M],\n        sum(data.weight[j, m] * x[m, j] for j in data.jobs) <= data.capacity[m])\n\n@objective(gap, Min,\n        sum(data.cost[j, m] * x[m, j] for m in M, j in data.jobs))","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Afterward, we apply the Dantzig-Wolfe decomposition according to axis M.","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"@dantzig_wolfe_decomposition(gap, dec, M)","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Now, we can solve the problem.","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"optimize!(gap)","category":"page"},{"location":"basic/#Logs-1","page":"Basic Example","title":"Logs","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Here is an example of the solver's basic log","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"warning: Warning\nTo be updated ...","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"For every node, we print the best known primal and dual bounds. Within a node, and for each column generation iteration, we print:","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"the objective value of the restricted master LP mlp\nthe number of columns added to the restricted master cols\nthe computed lagrangian dual bound in this iteration DB\nthe best integer primal bound PB","category":"page"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"We also use TimerOutputs.jl package to print, at the end of the resolution, the time consumed and the allocations made in most critical sections.","category":"page"},{"location":"basic/#Other-Examples-1","page":"Basic Example","title":"Other Examples","text":"","category":"section"},{"location":"basic/#","page":"Basic Example","title":"Basic Example","text":"Other examples are available here","category":"page"}]
}

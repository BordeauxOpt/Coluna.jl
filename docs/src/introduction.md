# Introduction

Coluna.jl solves Mixed Integer Programs (MIP) by applying reformulation
techniques such as Dantzig-Wolfe or Benders decomposition.
The reformulated problem is solved using a branch-and-price-and-cut
(column and row generation) algorithm. The specificity of Coluna.jl
is to offer a “black-box” implementation of the method:

1. the input is the set of constraints and variables of the MIP in
   its natural/compact formulation (formulated with JuMP or MOI);
2. the user specifies which of these constraints and variables define
   the subsystems on which the decomposition is based (it is handy to
   test different decompositions);
3. the reformulation is automatically generated by Coluna,
   without any input from the user to define master columns,
   their reduced cost, pricing/separation problem, or Lagrangian bound;
4. a default column generation procedure is implemented. It relies
   on underlying MOI optimizers to handle master and subproblem
   but the user can define its own optimizer;
5. a branching scheme that preserves the pricing problem structure
   is offered by default; it runs based on priorities and directives
   specified by the user on the original variables; default primal heuristics
   and preprocessing features are under developments.

!!! note
    Benders decomposition is not yet implemented but will be in the future.

## Dantzig-Wolfe decomposition

Consider the following problem :

```math
\begin{array}{c c c c c c c}
\text{minimize}  & \sum_{\alpha=1}^i f_\alpha x_\alpha     & + & \sum_{\alpha=1}^j f_{i+\alpha} x_{i+\alpha}     & + & \sum_{\alpha=1}^k f_{i+j+\alpha} x_{i+j+\alpha}   &      &             \\
\text{mc}_{1}:   & \sum_{\alpha=1}^i a_{1,\alpha} x_\alpha & + & \sum_{\alpha=1}^j a^{1}_{i+\alpha} x_{i+\alpha} & + & \sum_{\alpha=1}^k a_{1,i+j+\alpha} x_{i+j+\alpha} & \geq & \beta_{0,1} \\
\vdots           & \vdots                                  &   & \vdots                                          &   & \vdots                                            &      &             \\
\text{mc}_{m}:   & \sum_{\alpha=1}^i a_{m,\alpha} x_\alpha & + & \sum_{\alpha=1}^j a^{m}_{i+\alpha} x_{i+\alpha} & + & \sum_{\alpha=1}^k a_{m,i+j+\alpha} x_{i+j+\alpha} & \geq & \beta_{0,m} \\
\text{sc}_{1,1}: & \sum_{\alpha=1}^i b_{1,\alpha} x_\alpha &   &                                                 &   &                                                   & \geq & \beta_{1,1} \\
\vdots           & \vdots                                  &   &                                                 &   &                                                   &      &             \\
\text{sc}_{1,n}: & \sum_{\alpha=1}^i b_{n,\alpha} x_\alpha &   &                                                 &   &                                                   & \geq & \beta_{1,n} \\
\text{sc}_{2,1}: &                                         &   & \sum_{\alpha=1}^j c_{1,i+\alpha} x_{i+\alpha}   &   &                                                   & \geq & \beta_{2,1} \\
\vdots           &                                         &   & \vdots                                          &   &                                                   &      &             \\
\text{sc}_{2,p}: &                                         &   & \sum_{\alpha=1}^j c_{p,i+\alpha} x_{i+\alpha}   &   &                                                   & \geq & \beta_{2,p} \\
\text{sc}_{3,1}: &                                         &   &                                                 &   & \sum_{\alpha=1}^k d_{1,i+j+\alpha} x_{i+j+\alpha} & \geq & \beta_{3,1} \\
\vdots           &                                         &   &                                                 &   & \vdots                                            &      &             \\
\text{sc}_{3,q}: &                                         &   &                                                 &   & \sum_{\alpha=1}^k d_{q,i+j+\alpha} x_{i+j+\alpha} & \geq & \beta_{3,q} \\
\end{array}
```

The coefficients matrix has the following block structure :

![DWImg](static/matrixA_DW.png)

Hence, we can apply [Dantzig-Wolfe decomposition](https://en.wikipedia.org/wiki/Dantzig%E2%80%93Wolfe_decomposition)
on this problem.

We partition the constraints.
- Constraints ``\text{mc}_1`` to ``\text{mc}_m`` are in the master.
- Constraints ``\text{sc}_{1,1}`` to ``\text{sc}_{1,q}`` are in the first subproblem.
- Constraints ``\text{sc}_{2,1}`` to ``\text{sc}_{2,q}`` are in the second subproblem.
- Constraints ``\text{sc}_{3,1}`` to ``\text{sc}_{3,q}`` are in the third subproblem.

This decomposition is described through the following annotations:

```julia
# setting constraint annotations for the decomposition
for o in 1:3, p in 1:q
    # constraint in subproblem i
    # (subproblem annotations need to be contiguous starting at 1)
    set(model, Coluna.ConstraintDantzigWolfeAnnotation(), sc[o, p], i)
end
for o in 1:m
    # constraint in master (annotated with 0)
    set(model, Coluna.ConstraintDantzigWolfeAnnotation(), mc[o], 0)
end
# setting variable annotations for the decomposition in the same way
for o in 1:i
    set(model, Coluna.VariableDantzigWolfeAnnotation(), x[o], 1)
end
for o in (i+1):j
    set(model, Coluna.VariableDantzigWolfeAnnotation(), x[o], 2)
end
for o in (i+j+1):k
    set(model, Coluna.VariableDantzigWolfeAnnotation(), x[o], 2)
end
```

The decomposition can also be described in a more compact functional way:

```julia
function decomp_func(constr_name, constr_id)
    if constr_name == :mc
        return 0
    else
        return constr_id[1]
    end
end
Coluna.set_dantzig_wolfe_decompostion(model, decomp_func)
```
